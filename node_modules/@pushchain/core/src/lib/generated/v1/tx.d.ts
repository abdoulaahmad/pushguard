import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export declare const protobufPackage = "ue.v1";
/** Signature verification types */
export declare enum VerificationType {
    /** signedVerification - Signed verification using a signature */
    signedVerification = 0,
    /** universalTxVerification - Universal transaction verification */
    universalTxVerification = 1,
    UNRECOGNIZED = -1
}
export declare function verificationTypeFromJSON(object: any): VerificationType;
export declare function verificationTypeToJSON(object: VerificationType): string;
/** UniversalAccount is the identifier of a owner account */
export interface UniversalAccountId {
    /** chain_namespace is the CAIP-2 namespace of the chain where the owner is located (e.g. "eip155" for Ethereum) */
    chainNamespace: string;
    /** chain_id is the chain ID of the chain where the owner is located */
    chainId: string;
    /** Owner's public key bytes or address in hex format */
    owner: string;
}
/** MsgDeployUEA is the message used to deploy a new smart account. */
export interface MsgDeployUEA {
    /** signer is the Cosmos address initiating the tx (used for tx signing) */
    signer: string;
    /** universal_account is the identifier of the owner account */
    universalAccountId: UniversalAccountId | undefined;
    /** tx_hash is the hash of the transaction in which user locked the tokens */
    txHash: string;
}
/**
 * MsgMintPC represents a message to mint PUSH tokens to a smart account,
 * based on the amount locked by the user in the gateway contract.
 */
export interface MsgMintPC {
    /** signer is the Cosmos address initiating the tx (used for tx signing) */
    signer: string;
    /** universal_account is the identifier of the owner account */
    universalAccountId: UniversalAccountId | undefined;
    /** tx_hash is the hash of the transaction in which user locked the tokens */
    txHash: string;
}
/** UniversalPayload mirrors the Solidity struct */
export interface UniversalPayload {
    /** EVM address as hex string (0x...) */
    to: string;
    /** Amount in upc as string (uint256) */
    value: string;
    /** ABI-encoded calldata */
    data: string;
    /** uint256 as string */
    gasLimit: string;
    /** uint256 as string */
    maxFeePerGas: string;
    /** uint256 as string */
    maxPriorityFeePerGas: string;
    /** uint256 as string */
    nonce: string;
    /** uint256 as string */
    deadline: string;
    /** Type of signature verification */
    vType: VerificationType;
}
/** MsgExecutePayload defines a message for executing a universal payload */
export interface MsgExecutePayload {
    /** signer is the Cosmos address initiating the tx (used for tx signing) */
    signer: string;
    /** universal_account is the identifier of the owner account */
    universalAccountId: UniversalAccountId | undefined;
    /** payload is the universal payload to be executed */
    universalPayload: UniversalPayload | undefined;
    /** signature is the signature of the payload by user */
    verificationData: string;
}
export declare const UniversalAccountId: MessageFns<UniversalAccountId>;
export declare const MsgDeployUEA: MessageFns<MsgDeployUEA>;
export declare const MsgMintPC: MessageFns<MsgMintPC>;
export declare const UniversalPayload: MessageFns<UniversalPayload>;
export declare const MsgExecutePayload: MessageFns<MsgExecutePayload>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
