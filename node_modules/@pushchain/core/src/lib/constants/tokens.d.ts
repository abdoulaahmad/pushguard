import { CHAIN } from './enums';
export interface MoveableToken {
    symbol: string;
    decimals: number;
    address: string;
    mechanism: 'approve' | 'permit2' | 'native';
}
export interface PayableToken {
    symbol: string;
    decimals: number;
    address: string;
    mechanism: 'approve' | 'permit2' | 'native';
}
export type MoveableTokenMap = Partial<{
    ETH: MoveableToken;
    USDC: MoveableToken;
    USDT: MoveableToken;
    UNI: MoveableToken;
    WETH: MoveableToken;
    SOL: MoveableToken;
}>;
export type PayableTokenMap = Partial<{
    ETH: PayableToken;
    USDC: PayableToken;
    USDT: PayableToken;
    DAI: PayableToken;
    PEPE: PayableToken;
    UNI: PayableToken;
    WETH: PayableToken;
    SOL: PayableToken;
}>;
export declare class MoveableTokenAccessor {
    private readonly tokens;
    constructor(tokens: Record<string, MoveableToken>);
    private require;
    get ETH(): MoveableToken;
    get USDC(): MoveableToken;
    get USDT(): MoveableToken;
    get UNI(): MoveableToken;
    get WETH(): MoveableToken;
    get SOL(): MoveableToken;
}
export declare class PayableTokenAccessor {
    private readonly tokens;
    constructor(tokens: Record<string, PayableToken>);
    private require;
    get ETH(): PayableToken;
    get USDC(): PayableToken;
    get USDT(): PayableToken;
    get DAI(): PayableToken;
    get PEPE(): PayableToken;
    get UNI(): PayableToken;
    get WETH(): PayableToken;
    get SOL(): PayableToken;
}
export interface ConversionQuote {
    amountIn: string;
    amountOut: string;
    rate: number;
    route?: string[];
    timestamp: number;
}
export declare const MOVEABLE_TOKENS: Partial<Record<CHAIN, MoveableToken[]>>;
export declare const PAYABLE_TOKENS: Partial<Record<CHAIN, PayableToken[]>>;
