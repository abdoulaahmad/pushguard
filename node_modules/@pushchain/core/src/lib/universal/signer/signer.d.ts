import { WalletClient } from 'viem';
import { TypedDataDomain, TypedData } from '../../constants';
import { EthersV5SignerType, EthersV6SignerType, UniversalAccount, UniversalSigner, UniversalSignerSkeleton, ViemSignerType } from '../universal.types';
import { Keypair } from '@solana/web3.js';
import { CHAIN, LIBRARY } from '../../constants/enums';
import { ethers } from 'ethers';
/**
 * Creates a `UniversalSigner` object for signing messages and transactions
 * on any supported chain.
 *
 * @param {Object} params - The signer configuration object.
 * @param {string} params.address - The signer's address.
 * @param {(data: Uint8Array) => Promise<Uint8Array>} params.signMessage - Required function to sign messages.
 * @param {(data: Uint8Array) => Promise<Uint8Array>} [params.signAndSendTransaction] - Required function to sign and send transactions.
 * @param {CHAIN} params.chain - The chain the signer will operate on.
 * @returns {UniversalSigner} A signer object with chain metadata.
 *
 * @example
 * const signer = createUniversalSigner({
 *   chain: CHAIN.ETHEREUM_SEPOLIA
 *   address: "0xabc...",
 *   signMessage: async (data) => sign(data),
 *   signAndSendTransaction: async (data) => signRawTx(data),
 * });
 */
export declare function createUniversalSigner({ account, signMessage, signAndSendTransaction, signTypedData, }: UniversalSigner): UniversalSigner;
/**
 * Creates a UniversalSigner from either a viem, ethers, solana WalletClient or Account instance.
 *
 * @param {WalletClient | Account | Keypair | ethers.HDNodeWallet} clientOrAccount - The viem WalletClient or Account instance
 * @param {CHAIN} chain - The chain the signer will operate on
 * @returns {Promise<UniversalSigner>} A signer object configured for the specified chain
 */
export declare function toUniversalFromKeypair(clientOrAccount: WalletClient | Keypair | ethers.Wallet | ethers.HDNodeWallet, { chain, library }: {
    chain: CHAIN;
    library: LIBRARY;
}): Promise<UniversalSigner>;
export declare function construct(account: UniversalAccount, options: {
    signMessage: (data: Uint8Array) => Promise<Uint8Array>;
    signAndSendTransaction: (unsignedTx: Uint8Array) => Promise<Uint8Array>;
    signTypedData?: ({ domain, types, primaryType, message, }: {
        domain: TypedDataDomain;
        types: TypedData;
        primaryType: string;
        message: Record<string, any>;
    }) => Promise<Uint8Array>;
}): UniversalSignerSkeleton;
export declare function toUniversal(signer: UniversalSignerSkeleton | EthersV6SignerType | EthersV5SignerType | ViemSignerType): Promise<UniversalSigner>;
