"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PriceFetch = void 0;
const tslib_1 = require("tslib");
const enums_1 = require("../constants/enums");
const chain_1 = require("../constants/chain");
const evm_client_1 = require("../vm-client/evm-client");
const abi_1 = require("../constants/abi");
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const web3_js_2 = require("@solana/web3.js");
const anchor_2 = require("@coral-xyz/anchor");
class PriceFetch {
    constructor(rpcUrls = {}) {
        this.rpcUrls = rpcUrls;
    }
    getPrice(chain) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rpcUrls = this.rpcUrls[chain] || chain_1.CHAIN_INFO[chain].defaultRPC;
            const vm = chain_1.CHAIN_INFO[chain].vm;
            const { lockerContract } = chain_1.CHAIN_INFO[chain];
            if (!lockerContract) {
                throw new Error(`Locker contract not configured for chain: ${chain}`);
            }
            switch (vm) {
                case enums_1.VM.EVM: {
                    const evmClient = new evm_client_1.EvmClient({ rpcUrls });
                    const result = yield evmClient.readContract({
                        abi: abi_1.FEE_LOCKER_EVM,
                        address: lockerContract,
                        functionName: 'getEthUsdPrice',
                    });
                    const [price] = result;
                    return price;
                }
                case enums_1.VM.SVM: {
                    const PRICE_ACCOUNT = new web3_js_2.PublicKey('7UVimffxr9ow1uXYxsr4LHAcV58mLzhmwaeKvJ1pjLiE');
                    const connection = new web3_js_1.Connection(rpcUrls[0], 'confirmed');
                    const provider = new anchor_2.AnchorProvider(connection, {
                        publicKey: new web3_js_2.PublicKey('EfQYRThwBu4MsU7Lf3D2e68tCtdwfYj6f66ot1e2HNrq'),
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    }, { commitment: 'confirmed' });
                    const program = new anchor_1.Program(abi_1.FEE_LOCKER_SVM, provider);
                    const result = yield program.methods['getSolPrice']()
                        .accounts({
                        priceUpdate: PRICE_ACCOUNT,
                    })
                        .view();
                    if (!result || !result.price) {
                        throw new Error('Invalid price data returned');
                    }
                    // Exponent on this function is always NEGATIVE
                    const price = result.price.toNumber();
                    return BigInt(price);
                }
                default: {
                    throw new Error(`Unsupported VM ${vm}`);
                }
            }
        });
    }
}
exports.PriceFetch = PriceFetch;
//# sourceMappingURL=price-fetch.js.map